// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Pointer<OrtStatus>> _OrtStatusPtr =
      _lookup<ffi.Pointer<OrtStatus>>('OrtStatusPtr');

  ffi.Pointer<OrtStatus> get OrtStatusPtr => _OrtStatusPtr.value;

  set OrtStatusPtr(ffi.Pointer<OrtStatus> value) => _OrtStatusPtr.value = value;

  /// \brief The Onnxruntime library's entry point to access the C API
  ///
  /// Call this to get the a pointer to an ::OrtApiBase
  ffi.Pointer<OrtApiBase> OrtGetApiBase() {
    return _OrtGetApiBase();
  }

  late final _OrtGetApiBasePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<OrtApiBase> Function()>>(
          'OrtGetApiBase');
  late final _OrtGetApiBase =
      _OrtGetApiBasePtr.asFunction<ffi.Pointer<OrtApiBase> Function()>();
}

/// Copied from TensorProto::DataType
/// Currently, Ort doesn't support complex64, complex128
enum ONNXTensorElementDataType {
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED(0),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT(1),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8(2),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8(3),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16(4),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16(5),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32(6),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64(7),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING(8),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL(9),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16(10),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE(11),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32(12),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64(13),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64(14),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128(15),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16(16),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FN(17),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FNUZ(18),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2(19),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2FNUZ(20),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT4(21),
  ONNX_TENSOR_ELEMENT_DATA_TYPE_INT4(22);

  final int value;
  const ONNXTensorElementDataType(this.value);

  static ONNXTensorElementDataType fromValue(int value) => switch (value) {
        0 => ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED,
        1 => ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT,
        2 => ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8,
        3 => ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8,
        4 => ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16,
        5 => ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16,
        6 => ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32,
        7 => ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64,
        8 => ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING,
        9 => ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL,
        10 => ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16,
        11 => ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE,
        12 => ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32,
        13 => ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64,
        14 => ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64,
        15 => ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128,
        16 => ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16,
        17 => ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FN,
        18 => ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FNUZ,
        19 => ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2,
        20 => ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2FNUZ,
        21 => ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT4,
        22 => ONNX_TENSOR_ELEMENT_DATA_TYPE_INT4,
        _ => throw ArgumentError(
            "Unknown value for ONNXTensorElementDataType: $value"),
      };
}

enum ONNXType {
  ONNX_TYPE_UNKNOWN(0),
  ONNX_TYPE_TENSOR(1),
  ONNX_TYPE_SEQUENCE(2),
  ONNX_TYPE_MAP(3),
  ONNX_TYPE_OPAQUE(4),
  ONNX_TYPE_SPARSETENSOR(5),
  ONNX_TYPE_OPTIONAL(6);

  final int value;
  const ONNXType(this.value);

  static ONNXType fromValue(int value) => switch (value) {
        0 => ONNX_TYPE_UNKNOWN,
        1 => ONNX_TYPE_TENSOR,
        2 => ONNX_TYPE_SEQUENCE,
        3 => ONNX_TYPE_MAP,
        4 => ONNX_TYPE_OPAQUE,
        5 => ONNX_TYPE_SPARSETENSOR,
        6 => ONNX_TYPE_OPTIONAL,
        _ => throw ArgumentError("Unknown value for ONNXType: $value"),
      };
}

enum OrtSparseFormat {
  ORT_SPARSE_UNDEFINED(0),
  ORT_SPARSE_COO(1),
  ORT_SPARSE_CSRC(2),
  ORT_SPARSE_BLOCK_SPARSE(4);

  final int value;
  const OrtSparseFormat(this.value);

  static OrtSparseFormat fromValue(int value) => switch (value) {
        0 => ORT_SPARSE_UNDEFINED,
        1 => ORT_SPARSE_COO,
        2 => ORT_SPARSE_CSRC,
        4 => ORT_SPARSE_BLOCK_SPARSE,
        _ => throw ArgumentError("Unknown value for OrtSparseFormat: $value"),
      };
}

enum OrtSparseIndicesFormat {
  ORT_SPARSE_COO_INDICES(0),
  ORT_SPARSE_CSR_INNER_INDICES(1),
  ORT_SPARSE_CSR_OUTER_INDICES(2),
  ORT_SPARSE_BLOCK_SPARSE_INDICES(3);

  final int value;
  const OrtSparseIndicesFormat(this.value);

  static OrtSparseIndicesFormat fromValue(int value) => switch (value) {
        0 => ORT_SPARSE_COO_INDICES,
        1 => ORT_SPARSE_CSR_INNER_INDICES,
        2 => ORT_SPARSE_CSR_OUTER_INDICES,
        3 => ORT_SPARSE_BLOCK_SPARSE_INDICES,
        _ => throw ArgumentError(
            "Unknown value for OrtSparseIndicesFormat: $value"),
      };
}

/// \brief Logging severity levels
///
/// In typical API usage, specifying a logging severity level specifies the minimum severity of log messages to show.
enum OrtLoggingLevel {
  /// < Verbose informational messages (least severe).
  ORT_LOGGING_LEVEL_VERBOSE(0),

  /// < Informational messages.
  ORT_LOGGING_LEVEL_INFO(1),

  /// < Warning messages.
  ORT_LOGGING_LEVEL_WARNING(2),

  /// < Error messages.
  ORT_LOGGING_LEVEL_ERROR(3),

  /// < Fatal error messages (most severe).
  ORT_LOGGING_LEVEL_FATAL(4);

  final int value;
  const OrtLoggingLevel(this.value);

  static OrtLoggingLevel fromValue(int value) => switch (value) {
        0 => ORT_LOGGING_LEVEL_VERBOSE,
        1 => ORT_LOGGING_LEVEL_INFO,
        2 => ORT_LOGGING_LEVEL_WARNING,
        3 => ORT_LOGGING_LEVEL_ERROR,
        4 => ORT_LOGGING_LEVEL_FATAL,
        _ => throw ArgumentError("Unknown value for OrtLoggingLevel: $value"),
      };
}

enum OrtErrorCode {
  ORT_OK(0),
  ORT_FAIL(1),
  ORT_INVALID_ARGUMENT(2),
  ORT_NO_SUCHFILE(3),
  ORT_NO_MODEL(4),
  ORT_ENGINE_ERROR(5),
  ORT_RUNTIME_EXCEPTION(6),
  ORT_INVALID_PROTOBUF(7),
  ORT_MODEL_LOADED(8),
  ORT_NOT_IMPLEMENTED(9),
  ORT_INVALID_GRAPH(10),
  ORT_EP_FAIL(11);

  final int value;
  const OrtErrorCode(this.value);

  static OrtErrorCode fromValue(int value) => switch (value) {
        0 => ORT_OK,
        1 => ORT_FAIL,
        2 => ORT_INVALID_ARGUMENT,
        3 => ORT_NO_SUCHFILE,
        4 => ORT_NO_MODEL,
        5 => ORT_ENGINE_ERROR,
        6 => ORT_RUNTIME_EXCEPTION,
        7 => ORT_INVALID_PROTOBUF,
        8 => ORT_MODEL_LOADED,
        9 => ORT_NOT_IMPLEMENTED,
        10 => ORT_INVALID_GRAPH,
        11 => ORT_EP_FAIL,
        _ => throw ArgumentError("Unknown value for OrtErrorCode: $value"),
      };
}

enum OrtOpAttrType {
  ORT_OP_ATTR_UNDEFINED(0),
  ORT_OP_ATTR_INT(1),
  ORT_OP_ATTR_INTS(2),
  ORT_OP_ATTR_FLOAT(3),
  ORT_OP_ATTR_FLOATS(4),
  ORT_OP_ATTR_STRING(5),
  ORT_OP_ATTR_STRINGS(6);

  final int value;
  const OrtOpAttrType(this.value);

  static OrtOpAttrType fromValue(int value) => switch (value) {
        0 => ORT_OP_ATTR_UNDEFINED,
        1 => ORT_OP_ATTR_INT,
        2 => ORT_OP_ATTR_INTS,
        3 => ORT_OP_ATTR_FLOAT,
        4 => ORT_OP_ATTR_FLOATS,
        5 => ORT_OP_ATTR_STRING,
        6 => ORT_OP_ATTR_STRINGS,
        _ => throw ArgumentError("Unknown value for OrtOpAttrType: $value"),
      };
}

/// \addtogroup Global
/// ONNX Runtime C API
/// @{
final class OrtEnv extends ffi.Opaque {}

final class OrtStatus extends ffi.Opaque {}

final class OrtMemoryInfo extends ffi.Opaque {}

final class OrtIoBinding extends ffi.Opaque {}

final class OrtSession extends ffi.Opaque {}

final class OrtValue extends ffi.Opaque {}

final class OrtRunOptions extends ffi.Opaque {}

final class OrtTypeInfo extends ffi.Opaque {}

final class OrtTensorTypeAndShapeInfo extends ffi.Opaque {}

final class OrtMapTypeInfo extends ffi.Opaque {}

final class OrtSequenceTypeInfo extends ffi.Opaque {}

final class OrtOptionalTypeInfo extends ffi.Opaque {}

final class OrtSessionOptions extends ffi.Opaque {}

final class OrtCustomOpDomain extends ffi.Opaque {}

final class OrtModelMetadata extends ffi.Opaque {}

final class OrtThreadPoolParams extends ffi.Opaque {}

final class OrtThreadingOptions extends ffi.Opaque {}

final class OrtArenaCfg extends ffi.Opaque {}

final class OrtPrepackedWeightsContainer extends ffi.Opaque {}

final class OrtTensorRTProviderOptionsV2 extends ffi.Opaque {}

final class OrtCUDAProviderOptionsV2 extends ffi.Opaque {}

final class OrtCANNProviderOptions extends ffi.Opaque {}

final class OrtDnnlProviderOptions extends ffi.Opaque {}

final class OrtOp extends ffi.Opaque {}

final class OrtOpAttr extends ffi.Opaque {}

final class OrtLogger extends ffi.Opaque {}

final class OrtShapeInferContext extends ffi.Opaque {}

final class OrtLoraAdapter extends ffi.Opaque {}

/// \brief Memory allocation interface
///
/// Structure of function pointers that defines a memory allocator. This can be created and filled in by the user for custom allocators.
///
/// When an allocator is passed to any function, be sure that the allocator object is not destroyed until the last allocated object using it is freed.
final class OrtAllocator extends ffi.Struct {
  /// < Must be initialized to ORT_API_VERSION
  @ffi.Int()
  external int version;

  /// < Returns a pointer to an allocated block of `size` bytes
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<OrtAllocator> this_, ffi.Size size)>> Alloc;

  /// < Free a block of memory previously allocated with OrtAllocator::Alloc
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OrtAllocator> this_, ffi.Pointer<ffi.Void> p)>> Free;

  /// < Return a pointer to an ::OrtMemoryInfo that describes this allocator
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<OrtMemoryInfo> Function(
              ffi.Pointer<OrtAllocator> this_)>> Info;

  /// < Returns a pointer to an allocated block of `size` bytes
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<OrtAllocator> this_, ffi.Size size)>> Reserve;
}

/// \brief Graph optimization level
///
/// Refer to https://www.onnxruntime.ai/docs/performance/graph-optimizations.html#graph-optimization-levels
/// for an in-depth understanding of the Graph Optimization Levels.
enum GraphOptimizationLevel {
  ORT_DISABLE_ALL(0),
  ORT_ENABLE_BASIC(1),
  ORT_ENABLE_EXTENDED(2),
  ORT_ENABLE_ALL(99);

  final int value;
  const GraphOptimizationLevel(this.value);

  static GraphOptimizationLevel fromValue(int value) => switch (value) {
        0 => ORT_DISABLE_ALL,
        1 => ORT_ENABLE_BASIC,
        2 => ORT_ENABLE_EXTENDED,
        99 => ORT_ENABLE_ALL,
        _ => throw ArgumentError(
            "Unknown value for GraphOptimizationLevel: $value"),
      };
}

enum ExecutionMode {
  ORT_SEQUENTIAL(0),
  ORT_PARALLEL(1);

  final int value;
  const ExecutionMode(this.value);

  static ExecutionMode fromValue(int value) => switch (value) {
        0 => ORT_SEQUENTIAL,
        1 => ORT_PARALLEL,
        _ => throw ArgumentError("Unknown value for ExecutionMode: $value"),
      };
}

/// \brief Language projection identifiers
/// /see OrtApi::SetLanguageProjection
enum OrtLanguageProjection {
  ORT_PROJECTION_C(0),
  ORT_PROJECTION_CPLUSPLUS(1),
  ORT_PROJECTION_CSHARP(2),
  ORT_PROJECTION_PYTHON(3),
  ORT_PROJECTION_JAVA(4),
  ORT_PROJECTION_WINML(5),
  ORT_PROJECTION_NODEJS(6);

  final int value;
  const OrtLanguageProjection(this.value);

  static OrtLanguageProjection fromValue(int value) => switch (value) {
        0 => ORT_PROJECTION_C,
        1 => ORT_PROJECTION_CPLUSPLUS,
        2 => ORT_PROJECTION_CSHARP,
        3 => ORT_PROJECTION_PYTHON,
        4 => ORT_PROJECTION_JAVA,
        5 => ORT_PROJECTION_WINML,
        6 => ORT_PROJECTION_NODEJS,
        _ => throw ArgumentError(
            "Unknown value for OrtLanguageProjection: $value"),
      };
}

final class OrtKernelInfo extends ffi.Opaque {}

final class OrtKernelContext extends ffi.Opaque {}

final class OrtCustomOp extends ffi.Struct {
  @ffi.Int()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Int> op, ffi.Int OrtApi)>> CreateKernel;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Int> op)>> GetName;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Int> op)>>
      GetExecutionProviderType;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ffi.Int> op, ffi.Int size_t)>> GetInputType;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Int> op)>>
      GetInputTypeCount;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ffi.Int> op, ffi.Int size_t)>> GetOutputType;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Int> op)>>
      GetOutputTypeCount;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Int> op_kernel, ffi.Int OrtKernelContext)>>
      KernelCompute;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int> op_kernel)>>
      KernelDestroy;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ffi.Int> op, ffi.Int size_t)>> GetInputCharacteristic;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<ffi.Int> op, ffi.Int size_t)>>
      GetOutputCharacteristic;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Int> op, ffi.Int size_t)>>
      GetInputMemoryType;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int> op)>>
      GetVariadicInputMinArity;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int> op)>>
      GetVariadicInputHomogeneity;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int> op)>>
      GetVariadicOutputMinArity;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int> op)>>
      GetVariadicOutputHomogeneity;

  external ffi.NativeFunction<
      ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Int)>
          Function(ffi.Pointer<ffi.Int>)> OrtStatusPtr;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int> op)>>
      GetStartVersion;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int> op)>>
      GetEndVersion;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Pointer<ffi.Int>> input_index,
              ffi.Pointer<ffi.Pointer<ffi.Int>> output_index)>> GetMayInplace;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int> input_index,
              ffi.Pointer<ffi.Int> output_index)>> ReleaseMayInplace;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Pointer<ffi.Int>> input_index,
              ffi.Pointer<ffi.Pointer<ffi.Int>> output_index)>> GetAliasMap;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int> input_index,
              ffi.Pointer<ffi.Int> output_index)>> ReleaseAliasMap;
}

enum OrtCustomOpInputOutputCharacteristic {
  INPUT_OUTPUT_REQUIRED(0),
  INPUT_OUTPUT_OPTIONAL(1),
  INPUT_OUTPUT_VARIADIC(2);

  final int value;
  const OrtCustomOpInputOutputCharacteristic(this.value);

  static OrtCustomOpInputOutputCharacteristic fromValue(int value) =>
      switch (value) {
        0 => INPUT_OUTPUT_REQUIRED,
        1 => INPUT_OUTPUT_OPTIONAL,
        2 => INPUT_OUTPUT_VARIADIC,
        _ => throw ArgumentError(
            "Unknown value for OrtCustomOpInputOutputCharacteristic: $value"),
      };
}

/// \brief Memory types for allocated memory, execution provider specific types should be extended in each provider.
enum OrtMemType {
  /// < Any CPU memory used by non-CPU execution provider
  OrtMemTypeCPUInput(-2),

  /// < CPU accessible memory outputted by non-CPU execution provider, i.e. CUDA_PINNED
  OrtMemTypeCPUOutput(-1),

  /// < The default allocator for execution provider
  OrtMemTypeDefault(0);

  /// < Temporary CPU accessible memory allocated by non-CPU execution provider, i.e. CUDA_PINNED
  static const OrtMemTypeCPU = OrtMemTypeCPUOutput;

  final int value;
  const OrtMemType(this.value);

  static OrtMemType fromValue(int value) => switch (value) {
        -2 => OrtMemTypeCPUInput,
        -1 => OrtMemTypeCPUOutput,
        0 => OrtMemTypeDefault,
        _ => throw ArgumentError("Unknown value for OrtMemType: $value"),
      };

  @override
  String toString() {
    if (this == OrtMemTypeCPUOutput)
      return "OrtMemType.OrtMemTypeCPUOutput, OrtMemType.OrtMemTypeCPU";
    return super.toString();
  }
}

enum OrtAllocatorType {
  OrtInvalidAllocator(-1),
  OrtDeviceAllocator(0),
  OrtArenaAllocator(1);

  final int value;
  const OrtAllocatorType(this.value);

  static OrtAllocatorType fromValue(int value) => switch (value) {
        -1 => OrtInvalidAllocator,
        0 => OrtDeviceAllocator,
        1 => OrtArenaAllocator,
        _ => throw ArgumentError("Unknown value for OrtAllocatorType: $value"),
      };
}

/// \brief This mimics OrtDevice type constants so they can be returned in the API
enum OrtMemoryInfoDeviceType {
  OrtMemoryInfoDeviceType_CPU(0),
  OrtMemoryInfoDeviceType_GPU(1),
  OrtMemoryInfoDeviceType_FPGA(2);

  final int value;
  const OrtMemoryInfoDeviceType(this.value);

  static OrtMemoryInfoDeviceType fromValue(int value) => switch (value) {
        0 => OrtMemoryInfoDeviceType_CPU,
        1 => OrtMemoryInfoDeviceType_GPU,
        2 => OrtMemoryInfoDeviceType_FPGA,
        _ => throw ArgumentError(
            "Unknown value for OrtMemoryInfoDeviceType: $value"),
      };
}

/// \brief Algorithm to use for cuDNN Convolution Op
enum OrtCudnnConvAlgoSearch {
  OrtCudnnConvAlgoSearchExhaustive(0),
  OrtCudnnConvAlgoSearchHeuristic(1),
  OrtCudnnConvAlgoSearchDefault(2);

  final int value;
  const OrtCudnnConvAlgoSearch(this.value);

  static OrtCudnnConvAlgoSearch fromValue(int value) => switch (value) {
        0 => OrtCudnnConvAlgoSearchExhaustive,
        1 => OrtCudnnConvAlgoSearchHeuristic,
        2 => OrtCudnnConvAlgoSearchDefault,
        _ => throw ArgumentError(
            "Unknown value for OrtCudnnConvAlgoSearch: $value"),
      };
}

/// \brief CUDA Provider Options
///
/// \see OrtApi::SessionOptionsAppendExecutionProvider_CUDA
final class OrtCUDAProviderOptions extends ffi.Struct {
  /// \brief CUDA device Id
  /// Defaults to 0.
  @ffi.Int()
  external int device_id;

  /// \brief CUDA Convolution algorithm search configuration.
  /// See enum OrtCudnnConvAlgoSearch for more details.
  /// Defaults to OrtCudnnConvAlgoSearchExhaustive.
  @ffi.UnsignedInt()
  external int cudnn_conv_algo_searchAsInt;

  OrtCudnnConvAlgoSearch get cudnn_conv_algo_search =>
      OrtCudnnConvAlgoSearch.fromValue(cudnn_conv_algo_searchAsInt);

  /// \brief CUDA memory limit (To use all possible memory pass in maximum size_t)
  /// Defaults to SIZE_MAX.
  /// \note If a ::OrtArenaCfg has been applied, it will override this field
  @ffi.Size()
  external int gpu_mem_limit;

  /// \brief Strategy used to grow the memory arena
  /// 0 = kNextPowerOfTwo<br>
  /// 1 = kSameAsRequested<br>
  /// Defaults to 0.
  /// \note If a ::OrtArenaCfg has been applied, it will override this field
  @ffi.Int()
  external int arena_extend_strategy;

  /// \brief Flag indicating if copying needs to take place on the same stream as the compute stream in the CUDA EP
  /// 0 = Use separate streams for copying and compute.
  /// 1 = Use the same stream for copying and compute.
  /// Defaults to 1.
  /// WARNING: Setting this to 0 may result in data races for some models.
  /// Please see issue #4829 for more details.
  @ffi.Int()
  external int do_copy_in_default_stream;

  /// \brief Flag indicating if there is a user provided compute stream
  /// Defaults to 0.
  @ffi.Int()
  external int has_user_compute_stream;

  /// \brief User provided compute stream.
  /// If provided, please set `has_user_compute_stream` to 1.
  external ffi.Pointer<ffi.Void> user_compute_stream;

  /// \brief CUDA memory arena configuration parameters
  external ffi.Pointer<OrtArenaCfg> default_memory_arena_cfg;

  /// \brief Enable TunableOp for using.
  /// Set it to 1/0 to enable/disable TunableOp. Otherwise, it is disabled by default.
  /// This option can be overridden by environment variable ORT_CUDA_TUNABLE_OP_ENABLE.
  @ffi.Int()
  external int tunable_op_enable;

  /// \brief Enable TunableOp for tuning.
  /// Set it to 1/0 to enable/disable TunableOp tuning. Otherwise, it is disabled by default.
  /// This option can be overridden by environment variable ORT_CUDA_TUNABLE_OP_TUNING_ENABLE.
  @ffi.Int()
  external int tunable_op_tuning_enable;

  /// \brief Max tuning duration time limit for each instance of TunableOp.
  /// Defaults to 0 to disable the limit.
  @ffi.Int()
  external int tunable_op_max_tuning_duration_ms;
}

/// \brief ROCM Provider Options
///
/// \see OrtApi::SessionOptionsAppendExecutionProvider_ROCM
final class OrtROCMProviderOptions extends ffi.Struct {
  /// \brief ROCM device Id
  /// Defaults to 0.
  @ffi.Int()
  external int device_id;

  /// \brief ROCM MIOpen Convolution algorithm exaustive search option.
  /// Defaults to 0 (false).
  @ffi.Int()
  external int miopen_conv_exhaustive_search;

  /// \brief ROCM memory limit (To use all possible memory pass in maximum size_t)
  /// Defaults to SIZE_MAX.
  /// \note If a ::OrtArenaCfg has been applied, it will override this field
  @ffi.Size()
  external int gpu_mem_limit;

  /// \brief Strategy used to grow the memory arena
  /// 0 = kNextPowerOfTwo<br>
  /// 1 = kSameAsRequested<br>
  /// Defaults to 0.
  /// \note If a ::OrtArenaCfg has been applied, it will override this field
  @ffi.Int()
  external int arena_extend_strategy;

  /// \brief Flag indicating if copying needs to take place on the same stream as the compute stream in the ROCM EP
  /// 0 = Use separate streams for copying and compute.
  /// 1 = Use the same stream for copying and compute.
  /// Defaults to 1.
  /// WARNING: Setting this to 0 may result in data races for some models.
  /// Please see issue #4829 for more details.
  @ffi.Int()
  external int do_copy_in_default_stream;

  /// \brief Flag indicating if there is a user provided compute stream
  /// Defaults to 0.
  @ffi.Int()
  external int has_user_compute_stream;

  /// \brief User provided compute stream.
  /// If provided, please set `has_user_compute_stream` to 1.
  external ffi.Pointer<ffi.Void> user_compute_stream;

  /// \brief ROCM memory arena configuration parameters
  external ffi.Pointer<OrtArenaCfg> default_memory_arena_cfg;

  @ffi.Int()
  external int enable_hip_graph;

  /// \brief Enable TunableOp for using.
  /// Set it to 1/0 to enable/disable TunableOp. Otherwise, it is disabled by default.
  /// This option can be overridden by environment variable ORT_ROCM_TUNABLE_OP_ENABLE.
  @ffi.Int()
  external int tunable_op_enable;

  /// \brief Enable TunableOp for tuning.
  /// Set it to 1/0 to enable/disable TunableOp tuning. Otherwise, it is disabled by default.
  /// This option can be overridden by environment variable ORT_ROCM_TUNABLE_OP_TUNING_ENABLE.
  @ffi.Int()
  external int tunable_op_tuning_enable;

  /// \brief Max tuning duration time limit for each instance of TunableOp.
  /// Defaults to 0 to disable the limit.
  @ffi.Int()
  external int tunable_op_max_tuning_duration_ms;
}

/// \brief TensorRT Provider Options
///
/// \see OrtApi::SessionOptionsAppendExecutionProvider_TensorRT
final class OrtTensorRTProviderOptions extends ffi.Struct {
  /// < CUDA device id (0 = default device)
  @ffi.Int()
  external int device_id;

  @ffi.Int()
  external int has_user_compute_stream;

  external ffi.Pointer<ffi.Void> user_compute_stream;

  @ffi.Int()
  external int trt_max_partition_iterations;

  @ffi.Int()
  external int trt_min_subgraph_size;

  @ffi.Size()
  external int trt_max_workspace_size;

  @ffi.Int()
  external int trt_fp16_enable;

  @ffi.Int()
  external int trt_int8_enable;

  external ffi.Pointer<ffi.Char> trt_int8_calibration_table_name;

  @ffi.Int()
  external int trt_int8_use_native_calibration_table;

  @ffi.Int()
  external int trt_dla_enable;

  @ffi.Int()
  external int trt_dla_core;

  @ffi.Int()
  external int trt_dump_subgraphs;

  @ffi.Int()
  external int trt_engine_cache_enable;

  external ffi.Pointer<ffi.Char> trt_engine_cache_path;

  @ffi.Int()
  external int trt_engine_decryption_enable;

  external ffi.Pointer<ffi.Char> trt_engine_decryption_lib_path;

  @ffi.Int()
  external int trt_force_sequential_engine_build;
}

/// \brief MIGraphX Provider Options
///
/// \see OrtApi::SessionOptionsAppendExecutionProvider_MIGraphX
final class OrtMIGraphXProviderOptions extends ffi.Struct {
  @ffi.Int()
  external int device_id;

  @ffi.Int()
  external int migraphx_fp16_enable;

  @ffi.Int()
  external int migraphx_int8_enable;

  @ffi.Int()
  external int migraphx_use_native_calibration_table;

  external ffi.Pointer<ffi.Char> migraphx_int8_calibration_table_name;

  @ffi.Int()
  external int migraphx_save_compiled_model;

  external ffi.Pointer<ffi.Char> migraphx_save_model_path;

  @ffi.Int()
  external int migraphx_load_compiled_model;

  external ffi.Pointer<ffi.Char> migraphx_load_model_path;

  @ffi.Int()
  external int migraphx_exhaustive_tune;
}

/// \brief OpenVINO Provider Options
///
/// \see OrtApi::SessionOptionsAppendExecutionProvider_OpenVINO
final class OrtOpenVINOProviderOptions extends ffi.Struct {
  /// \brief Device type string
  ///
  /// Valid settings are one of: "CPU_FP32", "CPU_FP16", "GPU_FP32", "GPU_FP16"
  external ffi.Pointer<ffi.Char> device_type;

  /// < 0 = disabled, nonzero = enabled
  @ffi.UnsignedChar()
  external int enable_npu_fast_compile;

  external ffi.Pointer<ffi.Char> device_id;

  /// < 0 = Use default number of threads
  @ffi.Size()
  external int num_of_threads;

  external ffi.Pointer<ffi.Char> cache_dir;

  external ffi.Pointer<ffi.Void> context;

  /// < 0 = disabled, nonzero = enabled
  @ffi.UnsignedChar()
  external int enable_opencl_throttling;

  /// < 0 = disabled, nonzero = enabled
  @ffi.UnsignedChar()
  external int enable_dynamic_shapes;
}

/// \brief The C API
///
/// All C API functions are defined inside this structure as pointers to functions.
/// Call OrtApiBase::GetApi to get a pointer to it
///
/// \nosubgrouping
final class OrtApi extends ffi.Struct {
  /// \brief Create an OrtStatus from a null terminated string
  ///
  /// \param[in] code
  /// \param[in] msg A null-terminated string. Its contents will be copied.
  /// \return A new OrtStatus object, must be destroyed with OrtApi::ReleaseStatus
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<OrtStatus> Function(
              ffi.UnsignedInt code, ffi.Pointer<ffi.Int> msg)>> CreateStatus;

  /// \brief Get OrtErrorCode from OrtStatus
  ///
  /// \param[in] status
  /// \return OrtErrorCode that \p status was created with
  external ffi
      .Pointer<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Int OrtStatus)>>
      GetErrorCode;

  /// \brief Get error string from OrtStatus
  ///
  /// \param[in] status
  /// \return The error message inside the `status`. Do not free the returned value.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int OrtStatus)>>
      GetErrorMessage;

  /// \brief Create an OrtEnv
  ///
  /// \note Invoking this function will return the same instance of the environment as that returned by a previous call
  /// to another env creation function; all arguments to this function will be ignored.
  /// \param[in] log_severity_level The log severity level.
  /// \param[in] logid The log identifier.
  /// \param[out] out Returned newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv
  ///
  /// \snippet{doc} snippets.dox OrtStatus Return Value
  @ffi.Int()
  external int _Ret_maybenull_;

  /// @}
  /// \name OrtEnv
  /// @{
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtEnv)>>
      ReleaseEnv;

  /// @}
  /// \name OrtStatus
  /// @{
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtStatus)>>
      ReleaseStatus;

  /// @}
  /// \name OrtMemoryInfo
  /// @{
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtMemoryInfo)>>
      ReleaseMemoryInfo;

  /// @}
  /// \name OrtSession
  /// @{
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtSession)>>
      ReleaseSession;

  /// @}
  /// \name OrtValue
  /// @{
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtValue)>>
      ReleaseValue;

  /// @}
  /// \name OrtRunOptions
  /// @{
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtRunOptions)>>
      ReleaseRunOptions;

  /// @}
  /// \name OrtTypeInfo
  /// @{
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtTypeInfo)>>
      ReleaseTypeInfo;

  /// @}
  /// \name OrtTensorTypeAndShapeInfo
  /// @{
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Int OrtTensorTypeAndShapeInfo)>>
      ReleaseTensorTypeAndShapeInfo;

  /// @}
  /// \name OrtSessionOptions
  /// @{
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtSessionOptions)>>
      ReleaseSessionOptions;

  /// @}
  /// \name OrtCustomOpDomain
  /// @{
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtCustomOpDomain)>>
      ReleaseCustomOpDomain;

  /// @}
  /// \name OrtMapTypeInfo
  /// @{
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtMapTypeInfo)>>
      ReleaseMapTypeInfo;

  /// @}
  /// \name OrtSequenceTypeInfo
  /// @{
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Int OrtSequenceTypeInfo)>>
      ReleaseSequenceTypeInfo;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtModelMetadata)>>
      ReleaseModelMetadata;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Int OrtThreadingOptions)>>
      ReleaseThreadingOptions;

  /// \brief Release an ::OrtAllocator obtained from OrtApi::CreateAllocator
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtAllocator)>>
      ReleaseAllocator;

  /// \brief Release an ::OrtIoBinding obtained from OrtApi::CreateIoBinding
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtIoBinding)>>
      ReleaseIoBinding;

  /// \brief Clears any previously set Inputs for an ::OrtIoBinding
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtIoBinding)>>
      ClearBoundInputs;

  /// \brief Clears any previously set Outputs for an ::OrtIoBinding
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtIoBinding)>>
      ClearBoundOutputs;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtArenaCfg)>>
      ReleaseArenaCfg;

  /// \brief Release OrtPrepackedWeightsContainer instance
  ///
  /// \note instance must not be released until the sessions using it are released
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Int OrtPrepackedWeightsContainer)>>
      ReleasePrepackedWeightsContainer;

  /// \brief Release an ::OrtTensorRTProviderOptionsV2
  ///
  /// \note This is an exception in the naming convention of other Release* functions, as the name of the method does not have the V2 suffix, but the type does
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Int OrtTensorRTProviderOptionsV2)>>
      ReleaseTensorRTProviderOptions;

  /// \brief Release an ::OrtCUDAProviderOptionsV2
  ///
  /// \note This is an exception in the naming convention of other Release* functions, as the name of the method does not have the V2 suffix, but the type does
  ///
  /// \since Version 1.11.
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Int OrtCUDAProviderOptionsV2)>>
      ReleaseCUDAProviderOptions;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtOpAttr)>>
      ReleaseOpAttr;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtOp)>>
      ReleaseOp;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtKernelInfo)>>
      ReleaseKernelInfo;

  /// \name Ort Training
  /// @{
  ///   /** \brief Gets the Training C Api struct
  ///    *
  ///    * Call this function to access the ::OrtTrainingApi structure that holds pointers to functions that enable
  ///    * training with onnxruntime.
  ///    * \note A NULL pointer will be returned and no error message will be printed if the training api
  ///    * is not supported with this build. A NULL pointer will be returned and an error message will be
  ///    * printed if the provided version is unsupported, for example when using a runtime older than the
  ///    * version created with this header file.
  ///    *
  ///    * \param[in] version Must be ::ORT_API_VERSION
  ///    * \return The ::OrtTrainingApi struct for the version requested.
  ///    *
  ///    * \since Version 1.13
  ///    */
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<OrtTrainingApi> Function(ffi.Int version)>>
      GetTrainingApi;

  /// \brief Release an OrtCANNProviderOptions
  ///
  /// \param[in] the pointer of OrtCANNProviderOptions which will been deleted
  ///
  /// \since Version 1.13.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Int OrtCANNProviderOptions)>>
      ReleaseCANNProviderOptions;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtMemoryInfo)>>
      MemoryInfoGetDeviceType;

  /// \brief Release an ::OrtDnnlProviderOptions
  ///
  /// \since Version 1.15.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Int OrtDnnlProviderOptions)>>
      ReleaseDnnlProviderOptions;

  /// \brief Returns a null terminated string of the build info including git info and cxx flags
  ///
  /// \return UTF-8 encoded version string. Do not deallocate the returned buffer.
  ///
  /// \since Version 1.15.
  external ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>
      GetBuildInfoString;

  /// \brief Release an ::OrtROCMProviderOptions
  ///
  /// \note This is an exception in the naming convention of other Release* functions, as the name of the method does not have the V2 suffix, but the type does
  ///
  /// \since Version 1.16.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Int OrtROCMProviderOptions)>>
      ReleaseROCMProviderOptions;

  /// \brief Release an ::OrtLoraAdapter obtained from OrtApi::CreateLoraAdapter
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int OrtLoraAdapter)>>
      ReleaseLoraAdapter;
}

final class OrtTrainingApi extends ffi.Opaque {}

/// \brief The helper interface to get the right version of OrtApi
///
/// Get a pointer to this structure through ::OrtGetApiBase
final class OrtApiBase extends ffi.Struct {
  /// \brief Get a pointer to the requested version of the ::OrtApi
  ///
  /// \param[in] version Must be ::ORT_API_VERSION
  /// \return The ::OrtApi for the version requested, nullptr will be returned if this version is unsupported, for example when using a runtime
  /// older than the version created with this header file.
  ///
  /// One can call GetVersionString() to get the version of the Onnxruntime library for logging
  /// and error reporting purposes.
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Pointer<OrtApi> Function(ffi.Int version)>> GetApi;

  /// \brief Returns a null terminated string of the version of the Onnxruntime library (eg: "1.8.1")
  ///
  /// \return UTF-8 encoded version string. Do not deallocate the returned buffer.
  external ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>
      GetVersionString;
}

final class OrtCustomHandleType extends ffi.Struct {
  @ffi.Char()
  external int __place_holder;
}

const int ORT_API_VERSION = 20;

const String ORT_FILE = 'C';
